# Chapter 7. 신뢰성 있는 데이터 전달

- 아파치 카프카는 신뢰성 있는 데이터 전달에 있어서 매우 유연함.
- 웹사이트의 클릭 추적에서부터 신용카드 결제에 이르기까지 카프카에는 많은 활용 사례가 있음.

## 7.1 신뢰성 보장

- 카프카는 다음과 같은 내용을 보장함.
    - 카프카는 파티션 안의 메시지들 간의 순서를 보장함.
    - 클라이언트가 쓴 메시지는 모든 인-싱크 레플리카의 파티션에 쓰여진 뒤에야 커밋된 것으로 간주됨.
    - 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않음.
    - 컨슈머는 커밋된 메시지만 읽을 수 있음.

## 7.2 복제

- 레플리카는 파티션의 리더 레플리카이거나 아니면 아래의 조건을 만족하는 팔로워 레플리카인 경우 인-싱크 상태인 것으로 간주됨.
    - 주키퍼와의 활성 세션이 있음.
    - 최근 10초 사이 리더로부터 메시지를 읽어 옴.
    - 최근 10초 사이에 리더로부터 읽어 온 메시지들이 가장 최근 메시지임.
- 아웃-오브-싱크는 동기화가 풀린 상태라는 의미임.

## 7.3 브로커 설정

- 메시지 저장 신뢰성 관련된 카프카의 작동을 변경시키는 브로커의 설정 매개변수는 세 개가 있음.

### 7.3.1 복제 팩터

- 복제 팩터가 N이면 N-1개의 브로커가 중단되더라도 토픽의 데이터를 읽거나 쓸 수 있음.
- 따라서 복제 팩터가 클수록 가용성과 신뢰성은 늘어나고 장애가 발생할 가능성은 줄어듬.
- 반대로 복제 팩터가 N이라는 것은 최소한 N개의 브로커가 필요할 뿐더라 N개의 복사본을 저장해야 하므로 N배의 디스크 공간이 필요하다는 얘기임.
- 가용성과 하드웨어 사용량 사이에 트레이드오프가 있음.

### 7.3.2 언클린 리더 선출

- 아웃-오브-싱크 레플리카가 리더가 될 수 있도록 허용할 경우 데이터 유실과 일관성 깨짐의 위험성이 있음.
- 그렇지 않을 경우, 파티션이 다시 온라인 상태가 될 때까지 원래 리더가 복구되는 것을 기다려야 하는 만큼 가용성은 줄어듬.

### 7.3.3 최소 인-싱크 레플리카

- 인-싱크 레플리카가 하나만 남을 경우 해당 레플리카는 사실상 읽기 전용이 됨.

### 7.3.4 레플리카를 인-싱크 상태로 유지하기

- zookeeper.session.timeout.ms
    - 카프카 브로커가 주키퍼로 하트비트 전송을 멈출 수 있는 최대 시간을 정의함.
- replica.lag.time.max.ms
    - 레플리카가 설정된 값보다 더 오랫동안 리더로부터 데이터를 읽어오지 못하거나, 리더에 쓰여진 최신 메시지를 따라잡지 못하는 경우 동기화가 풀린상태 즉, 아웃오브싱크 상태가 됨.

### 7.3.5 디스크에 저장하기

- flush.messages
    - 디스크에 저장되지 않은 최대 메시지 수
- flush.ms
    - 얼마나 자주 디스크에 메시지를 저장하는지

## 7.4 신뢰성 있는 시스템에서 프로듀서 사용하기

- 카프카에 메시지를 쓰는 애플리케이션을 개발할 때 주의할 점
    - 신뢰성 요구 조건에 맞는 acks 설정을 사용할 것.
    - 설정과 코드 모두에서 에러를 올바르게 처리할 것.

### 7.4.1 응답 보내기

- ack=0
    - 프로듀서가 네트워크로 메시지를 전송한 시점에서 메시지가 카프카에 성공적으로 쓰여진 것으로 간주함.
- ack=1
    - 리더가 메시지를 받아서 파티션 데이터 파일에 쓴 직후 응답 또는 에러를 보낸다는 것을 의미함.
- ack=all
    - 리더가 모든 인싱크 레플리카가 메시지를 받아갈 때까지 기다렸다가 응답하거나 에러를 보내는 것을 의미함.

### 7.4.2 프로듀서 재시도 설정하기

- 프로듀서 에러 처리는 두 부분으로 나뉨.
    - 프로듀서가 자동으로 처리해주는 에러
    - 프로듀서 라이브러리를 사용하는 개발자들이 처리하는 에러
- 재시도와 주의 깊은 에러 처리는 각 메시지가 '최소 한 번' 저장되도록 보장할 수 있지만, '정확히 한 번'은 보장할 수 없음.

### 7.4.3 추가적인 에러 처리

- 개발자는 다른 종류의 에러도 처리해야 함.
    - 메시지 크기에 관련됐거나 인가 관련 에러와 같이 재시도가 불가능한 브로커 에러
    - 메시지가 브로커에 전송되기 전에 발생한 에러
    - 프로듀서가 모든 재전송 시도를 소진했거나, 재시도 과정에서 프로듀서가 사용하는 가용 메모리가 메시지로 가득 차서 발생하는 에러
    - 타임아웃

## 7.5 신뢰성 있는 시스템에서 컨슈머 사용하기

- 컨슈머는 카프카에 커밋된 데이터만 읽을 수 있음.
    - 즉, 모든 인싱크 레플리카에 쓰여진 다음부터 읽을 수 있음.
- 파티션으로부터 데이터를 읽어올 때, 컨슈머는 메시지를 배치 단위로 읽어온 뒤 배치별로 마지막 오프셋을 확인한 뒤, 브로커로부터 받은 마지막 오프셋 값에서 시작하는 다른 메시지 배치를 요청함.

### 7.5.1 신뢰성 있는 처리를 위해 중요한 컨슈머 설정

- 신뢰성을 갖는 컨슈머 설정은 4개임.
    - group.id
        - 같은 그룹ID를 갖는 두 개의 컨슈머가 같은 토픽을 구독할 경우, 각각의 컨슈머에는 해당 토픽 전체 파티션의 서로 다른 부분집합이 할당되므로 각각은 서로 다른 부분의 메시지만을 읽음.
    - auto.offset.reset
        - 커밋된 오프셋이 없을 때나 컨슈머가 브로커에 없는 오프셋을 요청할 때 컨슈머가 어떻게 할 지를 결정함.
    - enable.auto.commit
        - 일정 시간에 맞춰 컨슈머가 알아서 오프셋을 커밋하게 할 것인가? 직접 커밋할 것인가?
    - auto.commit.interval.ms
        - 오프셋을 자동으로 커밋할 경우, 이 설정을 사용해서 커밋되는 주기를 설정함.

### 7.5.2 컨슈머에서 명시적으로 오프셋 커밋하기

- 메시지 처리 먼저, 오프셋 커밋은 나중에
- 커밋 빈도는 성능과 크래시 발생시 중복 개수 사이의 트레이드오프임.
- 정확한 시점에 정확한 오프셋을 커밋.
- 리밸런스.
- 컨슈머는 재시도를 해야할 수도 있음.
- 컨슈머가 상태를 유지해야 할 수도 있음.

## 7.6 시스템 신뢰성 검증하기

### 7.6.1 설정 검증하기

- 리더 선출
    - 리더 정지시 어떻게 되는지
    - 재개까지 얼마나 걸리는지
- 컨트롤러 선출
    - 재시작 후 재개되는데 얼마나 걸리는지
- 롤링 재시작
    - 메시지 유실 없이 하나씩 재시작이 되는지
- 언클린 리더 선출 테스트
    - 한 파티션의 모든 레플리카를 하나씩 중단시키고 아웃오브싱크된 브로커를 시작하면 어떻게 되는지
    - 작업 재개하려면 어떻게 해야 하는지

### 7.6.2 애플리케이션 검증하기

- 클라이언트가 브로커 중 하나와 연결이 끊어짐
- 클라이언트와 브로커 사이의 긴 지연
- 디스크 꽉 참
- 디스크 멈춤
- 리더 선출
- 브로커 롤링 재시작
- 컨슈머 롤링 재시작
- 프로듀서 롤링 재시작

### 7.6.3 프로덕션 환경에서 신뢰성 모니터링하기

- JMX 지표

## 7.7 요약

- ...생략...

---

# Chapter 8. '정확히 한 번' 의미 구조

- 카프카의 '정확히 한 번' 의미 구조는 두 개의 핵심 기능의 조합으로 이루어짐
    - 멱등적 프로듀서
        - 재시도로 인해 발생하는 중복을 방지함.
    - 트랜잭션 의미 구조
        - 스트림 처리 애플리케이션에서 '정확히 한 번' 처리를 보장함.

## 8.1 멱등적 프로듀서

- 동일한 작업을 여러 번 실행해도 한 번 실행한 것과 결과가 같은 서비스를 멱등적이라고 함.
- 애플리케이션에서는 중복이 크게 문제가 되지 않음.
    - 하지만 재고가 맞지 않는다든가, 재무재표가 잘못된다든가, 하나를 주문했을 때 두 개를 배송한다든가 하는 문제가 있을 수 있음.

### 8.1.1 멱등적 프로듀서의 작동 원리

- 멱등적 프로듀서 기능을 키면 모든 메시지는 고유한 프로듀서 ID와 시퀀스 넘버를 가지게 됨.
- 브로커가 예전에 받은 적이 있는 메시지를 받게 될 경우, 적절한 에러를 발생시킴으로써 중복 메시지를 거부함.

- 멱등적 프로듀서가 어떻게 처리하는지 확인
    - 프로듀서 재시작
    - 브로커 장애

### 8.1.2 멱등적 프로듀서의 한계

- 카프카의 멱등적 프로듀서는 프로듀서의 내부 로직으로 인한 재시도가 발생할 경우 생기는 중복만을 방지함.

### 8.1.3 멱등적 프로듀서 사용법

- enable.idempotence=true
    - acks=all 이면 성능에 차이가 없을 것임.

## 8.2 트랜잭션

- 카프카의 트랜잭션 기능은 스트림 처리 애플리케이션을 위해 특별히 개발됨.
- 스트림 처리 애플리케이션의 기본 패턴인 읽기-처리-쓰기 패턴에서 사용하도록 개발됨.
- '정확히 한 번' 의미 구조를 보장할 수 잇음.

### 8.2.1 트랜잭션 활용 사례

- 금융 애플리케이션은 '정확히 한 번' 기능이 정확히 집적 결과를 보장하는 데 쓰이는, 복잡한 스트림 처리 애플리케이션의 전형적인 예임.

### 8.2.2 트랜잭션이 해결하는 문제

- 단순한 스트림 처리 애플리케이션은 다음과 같음.
    - 원본 토픽으로부터 이벤트를 읽어서, 처리를 한 다음, 결과를 다른 토픽에 씀.
- 정확히 한 번만 쓰여지고 싶다면?
    - 애플리케이션 크래시로 인한 재처리
        - 출력토픽에 쓰고, 오프셋을 커밋해야함.
        - 쓰긴 했으나 커밋을 못한 경우
    - 좀비 애플리케이션에 의해 발생하는 재처리
        - 중간에 연결이 끊어지는 경우

### 8.2.3 트랜잭션은 어떻게 '정확히 한 번'을 보장하는가?

- '정확히 한 번' 처리는 읽기, 처리, 쓰기 작업이 원자적으로 이뤄진다는 의미임.
- 읽어 온 원본 메시지의 오프셋이 커밋되고 결과가 성공적으로 쓰여지거나, 아니면 둘 다 안 일어나거나임.
- 부분적인 성공이 결코 일어나지 않을 것이라는 보장이 필요함.
    - 카프카 트랜잭션은 원자적 다수 파티션 쓰기 기능을 도입함.

### 8.2.4 트랜잭션으로 해결할 수 없는 문제들

- 카프카의 트랜잭션 기능이 정확히 한 번 보장에 도움이 되지 않는 몇 가지 경우
    - 스트림 처리에 있어서의 부수 효과
    - 카프카 토픽에서 읽어서 데이터베이스에 쓰는 경우
    - 데이터베이스에서 읽어서 카프카에 쓰고 여기서 다시 다른 데이터베이스에 쓰는 경우
    - 한 클러스터에서 다른 클러스터로 데이터 복제
    - 발행/구독 패턴

### 8.2.5 트랜잭션 사용법

- processing.guarantee=exactly_once or exactly_once_beta

### 8.2.6 트랜잭션 ID와 펜싱

- 2.5 버전까지 보장 없음.
- 2.5 이후는 리밸런스가 발생해도 트랜잭션적 레코드 프로세서가 잘 이뤄짐.

### 8.2.7 트랜잭션의 작동 원리

- 찬디-램포드 스냅샷 알고리즘의 영향을 받음.
- 알고리즘은 대략 다음과 같음.
    - 현재 진행중인 트랜잭션이 존재함을 로그에 기록함. 연관된 파티션들 역시 함께 기록함.
    - 로그에 커밋 혹은 중단 시도를 기록함.
        - 일단 로그에 기록이 남으면 최종적으로는 커밋되거나 중단되어야 함.
    - 모든 파티션에 트랜잭션 마커를 씀.
    - 트랜잭션이 종료되었음을 로그에 씀.

## 8.3 트랜잭션 성능

- 트랜잭션은 프로듀서에 약간의 오버헤드를 발생시킴.
- 프로듀서에 있어서 트랜잭션 오버헤드는 트랜잭션에 포함된 메시지의 수와는 무관함.
    - 트랜잭션마다 많은 수의 메시지를 집어넣는 쪽이 상대적으로 오버헤드가 적을 뿐 아니라 동기적으로 실행되는 단계의 수도 줄어듬.
    - 결과적으로 전체 처리량은 올라감.

## 8.4 요약

- ...생략...