# kafka consumer
<!-- note, tip, important, warning, caution-->
어플리케이션은 consumer를 사용해서 topic을 구독하고 해당 토픽에서 메시지를 수신
> [!NOTE]
> 다른 시스템과 다르게 몇가지 고유한 개념와 아이디어가 있음

## consumer 개념
topic에서 메시지를 읽으면 프로그램은 consumer 객체를 생성하고 토픽을 구독해서 메시지 수신 후 처리

topic에 메시지를 생성하는 속도보다 소비하는 속도가 더 빠르다면 consumer를 1개만 쓸 때 처리가 뒤쳐질 것임
* kafka가 consumer group을 도입한 이유

### consumer group
consumer는 일반적으로 consumer group의 일부이다.
* 동일한 토픽을 구독하는 같은 컨슈머 그룹에 속한 컨슈머들은 토픽에 있는 여러 파티션에서 메시지를 수신

#### 컨슈머 그룹 동작 방식
* 단일 컨슈머: 그룹의 유일한 컨슈머는 토픽의 모든 파티션에서 메시지를 받음
* 다수의 컨슈머: 컨슈머 그룹에 컨슈머를 추가하면 파티션이 컨슈머 간에 분배
* 파티션 제한: 컨슈머 수가 파티션 수를 초과하면 일부 컨슈머는 유휴 상태
  * 한 토픽의 파티션이 4개인데 컨슈머가 5개이면 일부 컨슈머는 놀고 있다는 뜻

> [!IMPORTANT]
> 컨슈머 그룹의 이점
> * 확장성: 컨슈머 그룹을 사용하면 여러 컨슈머가 동일한 토픽에서 읽을 수 있어 데이터 소비 확장
> * 부하 분산: 파티션이 컨슈머 간에 분배되어 처리 부하가 분산
> * 고가용성: 컨슈머 그룹은 장애 발생 시 자동으로 재조정되어 가용성을 상승
> * 병렬 처리: 여러 컨슈머가 동시에 다른 파티션에서 데이터를 처리 가능

> [!TIP]
> 여러 어플리케이션이 동일한 토픽의 데이터를 읽어야 할 때
> * 각 애플리케이션이 모든 메시지를 받도록 하려면 애플리케이션마다 고유한 컨슈머 그룹을 사용해야 한다.

<img width="525" alt="image" src="https://github.com/user-attachments/assets/83822155-1164-4656-95be-20c7ca4aa62f" />

고유한 컨슈머 그룹을 쓰면 장점
1. 메시지 전체 수신: 각 애플리케이션은 토픽의 모든 메시지를 받을 수 있음
2. 독립적 처리: 컨슈머 그룹은 서로 독립적으로 메시지를 처리
3. 확장성: Kafka는 성능 저하 없이 많은 수의 컨슈머와 컨슈머 그룹을 지원
#### 예시
기존 컨슈머 그룹에 새로운 컨슈머 그룹 G2를 추가하면
* G2의 단일 컨슈머는 G1과 무관하게 토픽의 모든 메시지를 받음
* G2에 여러 컨슈머가 있다면, 각 컨슈머는 파티션의 하위 집합을 받지만, G2 전체로는 여전히 모든 메시지를 받음

> [!IMPORTANT]
> 요약
> * 하나 이상의 토픽에서 모든 메시지가 필요한 각 애플리케이션에 대해 새로운 컨슈머 그룹을 생성합니다.
> * 기존 컨슈머 그룹에 컨슈머를 추가하여 토픽에서 메시지 읽기와 처리를 확장합니다. 이 경우 그룹 내 각 추가 컨슈머는 메시지의 일부만 받게 됩니다

## 컨슈머 그룹과 파티션 리벨런싱
분산 처리 시스템의 핵심 매커니즘이며 확장성과 고가용성을 제공
* 리벨런싱은 컨슈머 그룹 내에서 파티션 소유권을 재분배하는 프로세스이며 시스템의 변화에 유연하게 대응한다.

### 리밸런싱 트리거 및 프로세스
리밸런싱은 다음과 같은 상황에서 발생합

* 컨슈머 추가/제거: 새로운 컨슈머가 그룹에 합류하거나 기존 컨슈머가 종료/장애 발생 시.
* 토픽 파티션 변경: 관리자가 토픽에 새 파티션을 추가할 때.
* 컨슈머 장기 유휴: 일정 시간 하트비트(heartbeat)를 보내지 않으면 그룹에서 제외됩니다.

리밸런싱 프로세스는 다음과 같이 진행
* 그룹 코디네이터가 리밸런스 시작을 알림 → 모든 컨슈머가 파티션 소유권 포기.
* 그룹 리더(첫 번째 컨슈머)가 PartitionAssignor 전략을 사용해 새 할당 계획 생성.
* 새로운 파티션 배분이 컨슈머들에게 전달되고, 각 컨슈머는 할당된 파티션에서 데이터 처리 재개


* 리벨런싱의 종류는 컨슈머 그룹이 사용하는 파티션 할당 전략에 따라서 2가지가 있음
### 리밸런싱 유형

| 특징                | Eager 리밸런싱                          | Cooperative 리밸런싱                 |
|---------------------|----------------------------------------|-------------------------------------|
| **방식**            | 전체 파티션 소유권 일시 포기            | 증분 방식(일부 파티션만 재할당)     |
| **가용성 영향**     | 전체 컨슈머 그룹의 일시 중단 발생       | 부분적 중단만 발생                  |
| **단계**            | 2단계(파티션 해제 → 재할당)             | 다단계 점진적 재할당                |
| **적합 시나리오**   | 소규모 그룹                            | 대규모 그룹 또는 고가용성 요구 시스템|  

![image](https://github.com/user-attachments/assets/711316b7-e0cd-41f1-8e12-0e6bfcc5c2bc)
- **Eager**: 그림 4-6과 같이 모든 컨슈머가 파티션 소유권을 완전히 포기한 후 재할당, 이 과정에서 데이터 처리가 일시 중단

 ![image](https://github.com/user-attachments/assets/f3b3ce27-ddc5-42ab-bed4-b96bfa1f35fc)
- **Cooperative**: 그림 4-7과 같이 일부 파티션만 변경되며, 나머지 파티션은 계속 처리, "Stop-the-world" 현상을 방지

### 핵심 구성 요소 및 동작
* __그룹 코디네이터__: 브로커 중 하나가 담당하며, 컨슈머 그룹의 상태를 관리
* __하트비트 메커니즘__: 컨슈머는 주기적으로 하트비트를 전송해 활성 상태를 유지
* __오프셋 관리__: 리밸런싱 후 컨슈머는 마지막 커밋 오프셋부터 데이터 처리를 재개
> [!NOTE]
> session.timeout.ms(기본값 10초) 내에 하트비트 없으면 장애로 판단.


### 파티션 할당 전략
* Range: 파티션을 순차적으로 분배(예: 10개 파티션 → 3개 컨슈머 시 4-4-2 분배).
* RoundRobin: 균등한 분배를 위해 순환 할당.
* Sticky: 재밸런싱 시 파티션 이동을 최소화하는 전략.

> [!TIP]
> 리밸런싱은 카프카의 탄력성을 보장하지만, 빈번한 발생 시 시스템 성능에 영향을 미칩니다. 적절한 전략 선택과 구성 튜닝으로 이러한 overhead를 최소화할 수 있습니다.

## Commit과 Offset
![image](https://github.com/user-attachments/assets/d3a6d691-7e94-4e16-8a69-298f913320cf)

Kafka에서 **커밋(commit)**과 **오프셋(offset)**은 메시지 처리 상태를 추적하고 장애 복구를 위해 필수적인 메커니즘
* 오프셋은 파티션 내 메시지의 순차적 위치를 나타내는 정수이며, 컨슈머 그룹이 마지막으로 처리한 메시지를 기록.
* 이를 통해 시스템은 장애 발생 시 중단된 지점부터 재개할 수 있다

### 오프셋 커밋의 핵심 개념  
#### 1. **오프셋의 역할**  
- **로그-엔드-오프셋(Log-end-offset)**: 파티션의 마지막 메시지 위치
- **하이 워터마크(High watermark)**: 모든 복제본에 동기화된 메시지 위치
- **커밋된 오프셋(Committed offset)**: 컨슈머가 성공적으로 처리한 마지막 메시지 위치

커밋된 오프셋은 내부 토픽 `__consumer_offsets`에 저장되며, 리밸런싱 시 새 컨슈머가 이 값을 기준으로 처리 재개
![image](https://github.com/user-attachments/assets/2bd240e9-e902-4291-abf0-a695f366179d)

> [!IMPORTANT]
> 커밋 전략 비교  
> | 전략         | 설명                                                                 | 장단점                                                                 |
> |--------------|--------------------------------------------------------------------|-----------------------------------------------------------------------|
> | **자동 커밋**  | `enable.auto.commit=true` 설정 시, 주기적(기본 5초)으로 오프셋 커밋. | - **장점**: 간편함. - **단점**: 메시지 유실/중복 가능성 높음.              |
> | **수동 커밋**  | `enable.auto.commit=false` 설정 후 `commitSync()`/`commitAsync()` 호출. | - **장점**: 정확한 시점 제어. - **단점**: 개발자가 직접 로직 구현 필요. |


#### 2. **메시지 전달 보장**  
1. **최대 한 번(At-most-once)**  
   - 오프셋을 메시지 처리 **전** 커밋.  
   - **장점**: 처리 속도 빠름
   - **단점**: 장애 시 메시지 유실 가능
   ```java
   props.put("enable.auto.commit", true);
   props.put("auto.commit.interval.ms", "1000");
   ```

2. **최소 한 번(At-least-once)**  
   - 오프셋을 메시지 처리 **후** 커밋.  
   - **장점**: 유실 최소화.
   - **단점**: 중복 처리 가능
   ```java
   consumer.poll();
   processMessages();
   consumer.commitSync(); // 명시적 커밋
   ```

3. **정확히 한 번(Exactly-once)**  
   - **트랜잭션**과 **idempotent producer** 사용.  
   - **조건**: `enable.idempotence=true` 및 `processing.guarantee=exactly_once` 설정


### 주요 주의사항 및 모범 사례  
#### 1. **자동 커밋의 위험성**  
- **폴링 루프 중단 시**: `poll()` 호출 간격이 `max.poll.interval.ms` 초과하면 리밸런싱 발생
- **예시**: 5초마다 커밋되는 설정에서 3초 후 장애 발생 → 마지막 커밋 이후 3초간 데이터 재처리

#### 2. **수동 커밋 설정**  
- **Spring Kafka 예시**:  
  ```yaml
  spring.kafka.consumer.enable-auto-commit: false
  spring.kafka.listener.ack-mode: manual
  ```
  - `AckMode.MANUAL` 사용 시, `Acknowledgment.acknowledge()`로 명시적 커밋

#### 3. **오프셋 재설정 방법**  
- CLI: `kafka-consumer-groups --reset-offsets`
- API: `consumer.seek(partition, offset)`

### 결론  
- **자동 커밋**: 모니터링/로그 처리 등 유실 허용 시나리오에 적합
- **수동 커밋**: 금융 거래 등 정확성 요구 시스템에서 필수.  
- **성능 트레이드오프**: 처리 보장 강화 → 처리량 감소.  

> [!NOTE]
> 커밋 전략 선택은 애플리케이션의 **내결함성 요구사항**과 **처리량** 간 균형을 고려가 필요

