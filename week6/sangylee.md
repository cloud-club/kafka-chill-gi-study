# 7장: 신뢰할 수 있는 데이터 전달
신뢰성은 시스템의 속성이며 단일 구성 요소의 속성이 아닙니다.
따라서 카프카의 신뢰성 보장을 논할 때 전체 시스템과 그 사용 사례를 염두에 두어야 합니다.

Kafka와 통합되는 시스템은 Kafka 자체만큼 중요합니다. 
신뢰성은 시스템의 문제이므로, 이는 한 사람의 책임이 될 수 없습니다. 
* Kafka 관리자
* Linux 관리자
* 네트워크 및 스토리지 관리자
* 애플리케이션 개발자
모두가 협력하여 신뢰할 수 있는 시스템을 구축해야 합니다.

Apache Kafka는 신뢰할 수 있는 데이터 전달에 대해 매우 유연합니다. Kafka는 웹사이트 클릭 추적부터 신용카드 결제까지 다양한 사용 사례를 지원합니다. 일부 사용 사례는 최상의 신뢰성을 요구하지만, 다른 경우에는 신뢰성보다 속도와 단순성을 우선시합니다. Kafka는 이러한 모든 신뢰성 트레이드오프를 허용하도록 설계되었으며, 클라이언트 API도 유연하게 구성할 수 있습니다. 이러한 유연성 때문에 Kafka를 사용할 때 실수로 시스템이 신뢰할 수 없게 만들 수 있습니다. 이 장에서는 다양한 신뢰성 유형과 Kafka에서의 의미를 논의한 후, Kafka의 복제 메커니즘과 신뢰성에 대한 기여를 설명합니다. 이후 브로커와 토픽의 구성, 클라이언트(프로듀서와 컨슈머)의 사용 방법, 그리고 시스템 신뢰성 검증 방법에 대해 논의합니다.

신뢰성 보장
신뢰성을 논할 때 보통 보장에 대해 이야기합니다. 보장은 시스템이 다양한 상황에서 유지해야 할 행동 방식입니다. 가장 잘 알려진 신뢰성 보장은 ACID로, 이는 관계형 데이터베이스가 보장하는 표준입니다. ACID는 원자성, 일관성, 독립성, 지속성을 의미합니다. 데이터베이스 벤더가 자신의 데이터베이스가 ACID 규격에 맞다고 설명하면, 데이터베이스가 트랜잭션 행동에 대한 특정 행동을 보장한다는 의미입니다.

이러한 보장은 관계형 데이터베이스가 가장 중요한 애플리케이션에 신뢰받는 이유입니다. 사용자는 시스템이 어떤 상황에서도 어떻게 행동할지를 정확히 알 수 있으며, 이러한 보장을 기반으로 안전한 애플리케이션을 작성할 수 있습니다. Apache Kafka가 제공하는 보장을 이해하는 것은 신뢰할 수 있는 애플리케이션을 구축하려는 사람들에게 필수적입니다. 이러한 이해는 개발자가 시스템이 다양한 실패 조건에서 어떻게 행동할지를 파악하는 데 도움을 줍니다. 그렇다면 Apache Kafka는 무엇을 보장할까요?

메시지 순서 보장: 동일한 파티션 내에서 메시지 A가 메시지 B보다 먼저 기록되었다면, Kafka는 메시지 B의 오프셋이 A보다 높고, 컨슈머가 메시지 A를 읽은 후 메시지 B를 읽도록 보장합니다.

커밋된 메시지: 메시지는 모든 인-싱크 레플리카에 기록되면 커밋된 것으로 간주됩니다. 프로듀서는 메시지가 완전히 커밋되었을 때, 리더에 기록되었을 때, 또는 네트워크로 전송되었을 때 확인을 받을 수 있습니다.

데이터 손실 방지: 커밋된 메시지는 최소 하나의 레플리카가 살아 있는 한 손실되지 않습니다.

컨슈머의 읽기: 컨슈머는 커밋된 메시지만 읽을 수 있습니다.

이러한 기본적인 보장은 신뢰할 수 있는 시스템을 구축하는 데 사용될 수 있지만, 그 자체로는 시스템을 완전히 신뢰할 수 있게 만들지 않습니다. 신뢰할 수 있는 시스템을 구축하는 데에는 트레이드오프가 있습니다. Kafka는 관리자와 개발자가 신뢰성과 가용성, 처리량, 지연 시간, 하드웨어 비용 간의 균형을 조절할 수 있도록 설계되었습니다.

복제
Kafka의 복제 메커니즘은 신뢰성의 핵심입니다. 각 파티션은 여러 레플리카로 구성되며, 하나의 리더와 여러 팔로워가 있습니다. 모든 이벤트는 리더 레플리카에 기록되며, 일반적으로 리더 레플리카에서 소비됩니다. 다른 레플리카는 리더와 동기화되어 최신 이벤트를 복제합니다. 리더가 사용 불가능해지면 인-싱크 레플리카 중 하나가 새로운 리더가 됩니다.

레플리카는 다음과 같은 조건을 충족하면 인-싱크로 간주됩니다:

ZooKeeper와의 활성 세션: ZooKeeper에 최근 6초 이내에 하트비트를 보냄(설정 가능).

리더로부터 메시지 가져오기: 최근 10초 이내에 리더로부터 메시지를 가져옴(설정 가능).

최근 메시지 가져오기: 단순히 리더로부터 메시지를 가져오는 것만이 아니라, 최근 10초 이내에 최신 메시지를 가져와야 합니다(설정 가능).

레플리카가 ZooKeeper와의 연결을 잃거나 새로운 메시지를 가져오지 않으면 인-싱크 상태에서 벗어납니다. 인-싱크 상태에서 벗어난 레플리카는 ZooKeeper에 다시 연결되고 리더의 최신 메시지를 따라잡으면 다시 인-싱크 상태로 돌아옵니다.

브로커 구성
브로커에는 신뢰성과 관련된 세 가지 주요 구성 매개변수가 있습니다. 이 매개변수는 브로커 수준에서 설정되어 모든 토픽에 적용되거나, 특정 토픽에만 적용될 수 있습니다.

복제 인자
토픽 수준에서 replication.factor를 설정할 수 있으며, 브로커 수준에서는 자동으로 생성된 토픽의 기본 복제 인자를 제어하는 default.replication.factor가 있습니다. 복제 인자는 각 파티션의 복제본 수를 결정합니다. 일반적으로 복제 인자는 3으로 설정되지만, 이는 사용자가 수정할 수 있는 구성입니다. 복제 인자가 높을수록 가용성과 신뢰성이 높아지지만, 저장 공간과 네트워크 트래픽이 증가합니다.

복제 인자가 N인 경우, N-1개의 브로커가 손실되더라도 여전히 데이터를 읽고 쓸 수 있습니다. 그러나 복제 인자가 N이면 최소 N개의 브로커가 필요하며, 데이터를 N배로 저장해야 하므로 저장 공간이 N배로 증가합니다. 이는 가용성을 하드웨어 비용과 맞바꾸는 것입니다.

비정리된 리더 선거
이 구성은 브로커 수준에서만 설정할 수 있으며, 기본적으로는 비활성화되어 있습니다. unclean.leader.election.enable 매개변수는 비정리된 리더 선거를 허용하는지 여부를 결정합니다. 리더가 사용 불가능해지고 인-싱크 레플리카가 없을 때, 비정리된 리더 선거를 허용하면 커밋되지 않은 데이터가 손실될 수 있습니다.

이 상황은 두 가지 시나리오에서 발생할 수 있습니다:

팔로워 브로커 장애: 파티션이 세 개의 레플리카를 가지고 있고, 두 개의 팔로워 브로커가 사용 불가능해진 경우, 리더가 사용 불가능해지면 남은 팔로워가 새로운 리더가 될 수 있습니다. 이 경우 데이터 손실이 발생할 수 있습니다.

네트워크 문제로 인한 팔로워 지연: 두 개의 팔로워가 네트워크 문제로 인해 리더와 동기화되지 못한 상태에서 리더가 사용 불가능해지면, 비정리된 리더 선거를 허용하면 데이터 손실과 일관성 문제가 발생할 수 있습니다.

비정리된 리더 선거를 허용하지 않으면 파티션이 오프라인 상태로 남아 있게 되며, 이는 장애가 발생한 브로커를 복구할 때까지 지속될 수 있습니다. 반면에 비정리된 리더 선거를 허용하면 데이터 손실과 일관성 문제가 발생할 수 있습니다.

