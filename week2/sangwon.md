## 1.1 발행/구독 메시지 전달

초기 발행/구독 시스템
패턴은 전송자(발행하는 쪽)이 데이터(메시지)를 보낼 때 어떤 형태로든 브로커(중간 지점) 으로 보내고 수신자(읽는 쪽)은 이렇게 분류된 메시지 를 받는다. 

## 1.2 카프카 입문


### 1.2.1 메시지와 배치

**메시지**

- 카프카 데이터의 기본 단위는 `메시지`
- `키` 라는 메타 데이터 포함 가능 메시지를 저장할 파티션을 결정하기 위해 사용

**배치(batch)**

- 같은 토픽의 파티션에 쓰여지는 메시지의 집합
- 매시지를 배치 단위로 모아서 쓰면 네트워크 오버헤드 방지 (지연과 처리량 사이 trade off)
- 배치 크기가 커질수록 시간당 처리되는 메시지 수는 늘어나지만, 각각의 메시지가 전달되는데 걸리는 시간은 늘어난다.


### 1.2.2 스키마

- 메시지 즉, 내용 이해하기 쉽도록 일정한 구조(스키마)를 부여하는 것임
- 사용 가능한 스키마 여러가지
- 많은 개발자들이 JSON, XML 대신 아파치 에이브로(Avro)를 선호함
- 데이터 타이핑 기능, 스키마 버전간 호환성 유지를 지원한다


### 1.2.3 토픽과 파티션

- 매시지는 토픽이라는 단위로 분류 (파일 시스템 폴더 , DB 의 테이블)
- 토픽은 파티션이란 단위로 또 쪼개짐
- 메시지의 키가 동일한 경우에 한해서, 단일 `파티션 내에서만` 메시지의 순서가 보장된다
- 서로 다른 서버들이 동일한 파티션의 복제본을 저장하도록 파티션을 복제할 수 있다. 서버 중 하나에 장애가 발생하더라도 읽기나 쓰기가 가능하다
- `스트림(stream)` :  하나의 토픽에 저장된 데이터로 간주되며 프로듀서에서 컨슈머로의 하나의 데이터의 흐름을 뜻함. 


### 1.2.4 프로듀서와 컨슈머

- 프로듀서: 메시지를 발행한다. (발행자 ,작성자)
- 파티셔너: 메시지를 어떤 파티션에 할당할지 결정해준다. 키가 있는 경우 동일 키를 가진 메시지는 동일 파티션에 저장되는 것을 보장 키가 없으면 라운드 로빈 방식으로 메시지를 파티션에 할당.
- 컨슈머: 메시지를 읽는다. (구독자, 독자) 메시지의 `오프셋`(offset) 을 기록한다. 어떤 메시지까지 읽었는지 유지하기 위해 사용하는 지속적으로 증가하는 정수값. 메시지 저장 시 각각의 메시지에 부여하는 메타데이터.
- 컨슈머 그룹: 하나 이상의 컨슈머로 이루어진 집합. 각 파티션이 하나의 컨슈머에 의해서만 읽히도록 한다.

### 1.2.5 브로커와 클러스터

- 하나의 카프카 서버를 `브로커` 라 부른다.
프로듀서로부터 메시지를 전달받아 오프셋을 할당하고 디스크 저장소에 쓴다.

- 클러스터 여러 브로커로 구성 가능. 
여러 브로커에 동일 파티션을 복제해놓고, `리더 브로커`에 장애가 발생했을 때 `팔로워 브로커` 중 하나가 리더 역할을 이어받을 수 있도록 한다. 
여러 개의 브로커 중 하나가 `컨트롤러` 의 역할을 하며, 컨트롤러는 파티션을 브로커에 할당해주거나 장애가 발생한 브로커를 모니터링하는 등의 관리 기능을 한다. 
파티션이 여러 브로커에 복제되는 경우, 주 파티션을 `파티션 리더(partition leader)`, 나머지를 `팔로워(follower)`라고 부른다.
모든 프로듀서는 리더 브로커에 메시지를 발행해야하지만, 컨슈머는 리더나 팔로워 중 하나로부터 데이터를 읽어올 수 있다.



** 카프카 핵심 기능 보존기능(retention) **

디스크에 저장된 메시지를 특정 기간 동안 | 파티션의 크기가 특정 크기에 도달할 때까지 보존할 수 있다. 한도에 도달하면 메시지는 삭제된다.

`로그 압착(log compression)` 기능을 적용하면 같은 키를 갖는 메시지 중 가장 최신의 메시지만 저장된다. 최신 값 만 중요한 changelog 방식의 데이터에 로그 압착을 적용하면 좋다.
