# Chapter 6. 카프카 내부 메커니즘

- 아래 내용을 알면 명확한 의도를 가지고 설정값을 잡아주는 데 큰 도움이 됨.
  - 카프카 컨트롤러.
  - 카프카에서 복제가 작동하는 방식.
  - 카프카가 프로듀서와 컨슈머의 요청을 처리하는 방식.
  - 카프카가 저장을 처리하는 방식.

## 6.1 클러스터 멤버십

- 카프카는 현재 클러스터의 멤버인 브로커들의 목록을 유지하기 위해 아파치 주키퍼를 사용함.
- 브로커 프로세스는 시작될 때마다 주키퍼에 Ephemeral 노드의 형태로 ID를 등록함.
- 컨트롤러를 포함한 카프카 브로커들과 몇몇 생태계 툴들은 브로커가 등록되는 주키퍼의 /brokers/ids 경로를 구독함으로써 브로커가 추가되거나 제거될 때마다 알림을 받음.

## 6.2 컨트롤러

- 컨트롤러는 일반적인 카프카 브로커의 기능에 더해서 파티션 리더를 선출하는 역할을 추가적으로 맡음.
- 클러스터에서 가장 먼저 시작되는 브로커는 주키퍼의 /controller에 Ephemeral 노드를 생성함으로써 컨트롤러가 됨.
- 클러스터 안에 한 번에 한 개의 컨트롤러만 있도록 보장함.

- KRaft가 나온 이유
  - 컨트롤러가 주키퍼에 메타데이터를 쓰는 작업은 동기적, 브로커 메시지를 보내는 작업은 비동기적임. 브로커, 컨트롤러, 주키퍼 간에 메타데이터 불일치가 발생할 수 있음.
  - 컨트롤러가 재시작될 때마다 주키퍼로부터 모든 브로커와 파티션에 대한 메타데이터를 읽어와야 함. 파티션과 브로커의 수가 증가함에 따라 컨트롤러 재시작이 느려짐.
  - 메타데이터 소유권 관련 내부 아키텍처가 좋지 않음. 어떤 작업은 컨트롤러가, 어떤 작업은 브로커가, 어떤 작업은 주키퍼가 함.
  - 주키퍼는 그 자체로 분산 시스템이며, 카프카와 운영하기 위해서 지식이 있어야 함. 카프카를 사용하려면 두 개의 분산 시스템에 대해 배워야 함.

- KRaft 도입 이전
  - 주키퍼 프로세스
    - 카프카 클러스터의 동적 메타데이터를 저장하는 역할을 함.
    - 홀수 개의 프로세스가 하나의 쿼럼을 구성하며, 사용자 입장에서 명시적으로 보이지는 않지만 이 중에서 저장된 데이터의 업데이트 작업을 담당하는 리더 프로세스가 하나 있음.
  - 카프카 프로세스
    - 카프카 데이터를 저장하는 역할을 함.
    - 이들 중에서 리더 파티션을 결정하는 역할을 하는 프로세스를 컨트롤러라 함.
- KRaft 도입 이후
  - 컨트롤러
    - 카프카 클러스터의 동적 메타데이터를 저장하는 역할을 함.
    - 1개 이상의 프로세스가 하나의 쿼럼을 구성하며, 이들 중에서 저장된 데이터의 업데이트 및 조회 작업을 담당하는 프로세스를 액티브 컨트롤러라고 함.
  - 브로커
    - 카프카 데이터를 저장하는 역할을 함.
    - 하나의 컨트롤러 쿼럼을 사용하는 브로커들이 모여 하나의 클러스터를 이룸.

## 6.3 복제

- 복제는 카프카 아키텍처의 핵심임.
- 개별적인 노드에 필연적으로 장애가 바생할 수밖에 없는 상황에서 카프카가 신뢰성과 지속성을 보장하는 방식임.

- 카프카에 저장되는 데이터는 토픽을 단위로 해서 조직화됨.
- 각 토픽은 1개 이상의 파티션으로 분할되며, 각 파티션은 다시 다수의 레플리카를 가질 수 있음.

- 레플리카에는 두 종류가 있음.
  - 리더 레플리카
    - 각 파티션에는 리더 역할을 하는 레플리카가 하나씩 있음.
    - 일관성을 보장하기 위해, 모든 쓰기 요청은 리더 레플리카로 주어짐.
    - 클라이언트들은 리더 레플리카나 팔로워로부터 레코드를 읽어옴.
  - 팔로워 레플리카
    - 파티션에 속한 모든 레플리카 중에서 리더 레플리카를 제외한 나머지를 팔로워 레플리카라고 함.
    - 이들은 주로 리더 레플리카로 들어온 최근 메시지들을 복제함으로써 최신 상태를 유지함.
    - 특정 파티션의 리더 레플리카에 크래쉬가 날 경우, 팔로워 중 하나가 파티션의 새 리더 파티션으로 승격됨.

## 6.4 요청 처리

- 카프카 브로커가 하는 일의 대부분은 클라이언트, 파티션 레플리카, 컨트롤러가 파티션 리더에게 보내는 요청을 처리하는 것임.
- 카프카는 TCP로 전달되는 이진 프로토콜을 가지고 있음.
- 이 프로토콜은 요청의 형식과 브로커가 응답하는 방식을 정의함.

- 언제나 클라이언트가 연결을 시작하고 요청을 전송하며, 브로커는 요청을 처리하고 클라이언트로 응답을 보냄.
- 특정 클라이언트가 브로커로 전송한 모든 요청은 브로커가 받은 순서대로 처리함.
- 그래서 카프카가 저장하는 메시지는 순서가 보장되며, 카프카를 메시지 큐로 사용할 수 있음.

- 모든 요청을 아래의 표준 헤더를 가짐.
  - 요청 유형: API 키
  - 요청 버전: 브로커는 서로 다른 버전의 클라이언트로부터 요청을 받아 각각의 버전에 맞는 응답을 할 수 있음.
  - Correlation ID: 각각의 요청에 붙는 고유한 식별자.
  - Client ID: 요청을 보낸 애플리케이션을 식별하기 위해 사용함.

## 6.5 물리적 저장소

- 카프카의 기본 저장 단위는 파티션 레플리카임.
- 파티션은 서로 다른 브로커들 사이에 분리될 수 없으며, 같은 브로커의 서로 다른 디스크에 분할 저장되는 것조차 불가능함.
- 따라서 파티션의 크기는 특정 마운트 지점에 사용 가능한 공간에 제한을 받음.

## 6.6 요약


