# Chapter 5. 프로그램 내에서 코드로 카프카 관리하기

- 아파치 카프카 버전 0.11 이전까지는 명령줄 프로그램으로만 가능했던 관리 기능이 가능했음.
- 0.11부터 프로그램적인 관리 기능 API를 제공하기 위한 목적으로 AdminClient가 추가됨.
- 토픽 목록 조회, 생성, 삭제, 클러스터 상세 정보 확인, ACL 관리, 설정 변경 등의 기능이 이것으로 가능함.

## 5.1 AdminClient 개요

- 카프카의 AdminClient를 이해할 때 가장 중요한 것은 이것이 비동기적으로 작동한다는 사실임.
- 각 메서드는 요청을 클러스터 컨트롤러 전송한 뒤 바로 1개 이상의 Future 객체르 리턴함.

- 클러스터의 상태를 변경하는 모든 작업은 컨트롤러에 의해 수행됨.
- 클러스터 상태를 읽기만 하는 작업은 아무 브로커에서나 수행될 수 있으며, 크라이언트 입장에서 보이는 가장 부하가 적은 브로커로 전달됨.

## 5.2 AdminClient 사용법: 생성, 설정, 닫기

- AdminClient 생성 방법은 다음과 같음.
```java
Properties props = new Properties();
props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
AdminClient admin = AdminClient.create(props);
// TODO: AdminClient를 사용해서 필요한 작업을 수행한다.
admin.close(Duration.ofSeconds(30));
```
- 정적 메서드인 create 메서드는 설정값을 담고 있는 Properties 객체를 인수로 받음.
- 반드시 있어야 하는 설정은 클러스터에 대한 URI 하나뿐임.
- 프로덕션 환경에서는 브로커 중 하나에 장애가 발생할 경우를 대비해서 최소한 3개 이상의 브로커를 지정하는 것이 보통임.

## 5.3 필수적인 토픽 관리 기능

- 클러스터에 있는 토픽 목록 조회 방법은 다음과 같음.
```java
ListTopicsResult topics = admin.listTopics();
topics.names().get().forEach(System.out::println);
```
- admin.listTopics()가 Future 객체들을 감싸고 있는 ListTopicsResult 객체를 리턴함.
- topics.name()는 토픽 이름의 집합에 대한 Future 객체를 리턴함.
- 이 Future 객체에서 get 메서드를 호출하면, 실행 스레드는 서버가 토픽 이름 집합을 리턴할 때까지 기다리거나 아니면 타임아웃 예외를 발생시킴.
- 토픽 이름 집합을 받으면 우리는 반복문을 사용해 모든 토픽 이름을 출력할 수 있음.

## 5.4 설정 관리

- 설정 관리는 ConfigResource 객체를 사용해서 할 수 있음.
- 설정 가능한 자원에는 브로커, 브로커 로그, 토픽이 있음.
- 브로커와 브로커 로깅 설정을 확인하고 변경하는 작업은 kafka-configs.sh 혹은 다른 카프카 관리 툴을 사용해서 하는게 보통이지만, 애플리케이션에서 사용하는 토픽의 설정을 확인하거나 수정하는 것은 흔함.

- 예를 들어서, 많은 애플리케이션들은 정확한 작동을 위해 압착 설정이 된 토픽을 사용함.
- 이 경우 애플리케이션이 주기적으로 해당 토픽에 실제로 압착 설정이 되어 있는지를 확인해서, 설정이 안 되어 있을 경우 설정을 교정해주는 것이 합리적임.

## 5.5 컨슈머 그룹 관리

- 컨슈머 그룹 살펴보기
- 컨슈머 그룹 수정
  - 오프셋 변경 기능이 가장 유용함.
    - 오프셋 토픽의 오프셋 값을 변경한다 해도 컨슈머 그룹에 변경 여부가 전달되지는 않음.
    - 컨슈머 그룹은 컨슈머가 새로운 파티션을 할당받거나 새로 시작할 때만 오프셋 토픽에 저장된 값을 읽어옴.
    - 컨슈머가 모르는 오프셋 변경을 방지하기 위해 카프카에서는 현재 작업이 돌아가고 있는 컨슈머 그룹에 대한 오프셋을 수정하는 것을 허용하지 않음.

## 5.6 클러스터 메타데이터

- 애플리케이션이 연결된 클러스터에 대한 정보를 명시적으로 읽어와야 하는 경우는 드뭄.
- 얼마나 많은 브로커가 있는지, 어느 브로커가 컨트롤러인지 알 필요 없이 메시지를 읽거나 쓸 수 있기 때문임.
- 카프카 클라이언트는 이러한 정보들을 추상화함.
  - 클라이언트는 토픽과 파티션에 대한 정보만 알면 됨.

## 5.7 고급 어드민 작업

- 토픽에 파티션 추가하기
- 토픽에서 레코드 삭제하기
- 리더 선출
- 레프리카 재할당

## 5.8 테스트하기

- 카프카는 원하는 수만큼의 브로커를 설정해서 초기화할 수 있는 MockAdminClient 테스트 클래스를 제공함.
- 이 클래스를 사용하면 실제 카프카 클러스터르 돌려서 거기에 실제 어드민 작업을 수행할 필요 없이 애플리케이션이 제대로 작동하는지 확인할 수 있음.
- 테스트 클래스에서 주목할 만한 점은 자주 사용되는 메서드가 매우 포괄적인 목업 기능을 제공함.
- MockAdminClient의 토픽 생성 메서드를 호출한 뒤 listTopics()를 호출하면 방금 전 생성한 토픽이 리턴됨.

## 5.9 요약

- AdminClient는 카프카 개발 키트에 챙겨 둘 가치가 있는 유용한 툴임.
- 이것은 즉석에서 토픽을 생성하고나 애플리케이션이 사용할 토픽이 올바른 설정을 가지고 있는지를 확인해야 하는 애플리케이션 개발자들에게 유용함.
- AdminClient는 툴을 개발해야 하거나, 카프카 작업을 자동화하거나, 사고가 발생했을 때 복구해야 하는 운영자나 SRE에게도 쓸모가 많음.
