## 4장 카프카 컨슈머

카프카에서 데이터를 읽는 애플리케이션은 토픽을 Subscribe하고, 토픽들로부터 메시지를 받기 위해 KafkaConsumer를 사용한다.

컨슈머 API 사용법을 이해하고 다양한 요구 조건을 가진 애플리케이션에서 컨슈머 API가 어떻게 활용되는지 살펴본다.
___

### 컨슈머와 컨슈머 그룹

- 컨슈머 그룹은 병렬 처리를 위해 컨슈머를 그룹화한 단위
- 동일 그룹 내 컨슈머는 각기 다른 파티션 데이터를 처리 (그룹 내 컨슈머가 사용중인 파티션은 접근할 수 없음)
- 파티션 수보다 많은 컨슈머는 유휴 상태로 전환됨

1. 네 개의 파티션과 하나의 컨슈머 (컨슈머1이 모든 파티션에서 토픽에 대한 메시지를 읽어옴)
```
토픽 T1      컨슈머 그룹1
파티션 0  ->    컨슈머 1
파티션 1  ->
파티션 2  ->
파티션 3  ->
```
2. 네 개의 파티션과 컨슈머 그룹에 두 컨슈머 (컨슈머1,2는 각 2개의 파티션에서 토픽에 대한 메시지를 읽어옴)
```
토픽 T1      컨슈머 그룹1
파티션 0  ->    컨슈머 1
파티션 1  ->    
파티션 2  ->    컨슈머 2
파티션 3  ->
```
3. 네 컨슈머가 존재하면 각 파티션 하나씩 할당받음
4. 파티션 개수보다 컨슈머 그룹에 속한 컨슈머가 더 많다면 유휴 컨슈머가 발생

카프카 컨슈머는 지연 시간이 긴 작업(DB Write, Long Operation)을 수행하는 것이 흔하기 때문에 컨슈머를 추가함으로써 단위 컨슈머가 처리하는 파티션과 메시지의 수를 분산시키는 것이 일반적인 Scaling

새로운 컨슈머 그룹이 추가되면 기존 컨슈머 그룹과는 독립적으로 파티션에 접근할 수 있음 (두 컨슈머 그룹이 같은 파티션 접근 가능)

=> 애플리케이션이 각자의 컨슈머 그룹을 갖도록해 전통적인 메시지 전달 시스템과 다르게 카프카는 성능 저하 없이 많은 수의 컨슈머와 컨슈머 그룹으로 확장 가능
___

### 컨슈머 그룹과 파티션 리밸런스

컨슈머 그룹에 컨슈머가 추가되거나 컨슈머가 종료되었을때 (장애 등) 해당 컨슈머가 읽던 파티션들은 그룹에 있던 다른 컨슈머 중 하나가 받아서 읽게 됨
- 컨슈머에 할당된 파티션을 다른 컨슈머에 할당하는 작업을 리밸런스라고 함

파티션 리밸런스 전략은 2가지가 있음

1. Eager Rebalance: 컨슈머가 할당받은 모든 파티션 할당을 해제한 후 작업을 정지시키고, 파티션을 다시 할당
2. Cooperative Rebalance: 전체 파티션 중 재할당될 것들에 한정해서 작업을 정지시키고, 파티션을 다시 할당 (전체 작업 중단을 방지시키나, 컨슈머가 많은 상황에서는 리밸런싱이 오래걸릴 수 있음)

### 정적 그룹 멤버십 

기본적으로 컨슈머는 일시적 멤버로, 그룹을 떠나면 기존 파티션이 해제됨

group.instance.id를 설정하면 정적 그룹 멤버십이 활성화되어 종료 후에도 동일한 파티션을 유지함
- 종료 후 재참여해도 동일한 파티션을 재할당받아 리밸런스를 방지
- 동일한 group.instance.id를 가진 컨슈머가 중복 조인하면 에러가 발생
- 종료 시 컨슈머 그룹을 떠나지 않으며, session.timeout.ms 설정에 따라 멤버십이 해제됨 (잠시 컨슈머가 종료됐다가 돌아오는 시간보단 크면서, 파티션 재할당이 안이루어져 멈추는 상황을 막을 수 있는 작은 시간이어야 함)
___
### 카프카 컨슈머 생성하기
KafkaConsumer 인스턴스를 생성하여 컨슈머를 정의한다.

프로듀서와 생성 방식이 유사 (group.id 설정 추가)
```
필수 설정
bootstrap.servers : 카프카 브로커 주소
key.deserializer, value.deserializer : 바이트 데이터를 자바 객체로 변환할 클래스
group.id: 컨슈머 그룹 ID. 동일 그룹 내 컨슈머끼리 데이터를 병렬로 처리

추가 설정
auto.offset.reset : 초기 메시지 소비 위치
earliest: 처음부터 읽음
latest: 최신 메시지부터 읽음
none: 오프셋이 없으면 에러 발생
enable.auto.commit : 오프셋 자동 커밋 여부
true: 자동 커밋
false: 수동 커밋 필요
```
___
### 토픽 구독하기
- subscribe() 메서드로 하나 이상의 토픽을 구독
- 토픽 목록을 직접 지정하거나, 정규식을 사용해 특정 패턴의 토픽을 구독
- 정규식을 활용하면 새로운 토픽 추가 시 자동으로 구독에 포함
```
// 단일 또는 다수의 토픽 구독
consumer.subscribe(Collections.singletonList("customerCountries"));

// 특정 패턴의 토픽 구독
consumer.subscribe(Pattern.compile("test.*"));
```
___
### 폴링 루프

- poll() 메서드는 컨슈머가 주기적으로 데이터를 확인하고 처리하는 루프
- 데이터를 기다리는 동안 설정된 시간만큼 대기하며, 새로운 데이터가 오면 처리함
- 폴링을 멈추면 컨슈머가 죽은 것으로 간주되어 리밸런스가 발생할 수 있음 (max.poll.interval.ms 보다 오래 폴링을 안하면)
- 첫 번째 poll() 호출 시
    - GroupCoordinator를 찾아 컨슈머 그룹에 참여
    - 파티션을 할당받고 리밸런스 처리 수행

### Thread Safe
- 하나의 스레드에서 동일 그룹 여러 컨슈머 생성 X
- 같은 컨슈머를 다수의 스레드가 안전하게 사용 X
- 하나의 스레드 하나의 컨슈머 원칙을 지키고, 여러 스레드를 생성하여 각각에 컨슈머를 시작시켜라
___
### 컨슈머 설정하기

#### 데이터 처리 관련 설정

- `fetch.min.bytes` : 브로커에서 읽어올 최소 데이터 크기 지정 (새로 보낼 레코드가 min보다 작으면 브로커는 기다렸다 min보다 클 때 보냄)
- `fetch.max.wait.ms` : 데이터가 쌓일 때까지 대기 시간 지정 (브로커는 데이터가 최소값보다 쌓이거나 대기 시간이 지나거나 일 때 데이터를 리턴하게 된다)
- `fetch.max.bytes` : 한 번에 가져올 최대 데이터 크기 지정 (컨슈머가 서버로부터 받은 데이터 저장에 사용되는 메모리 제한을 위함, 또한 브로커 부하를 줄이기 위함)
- `max.poll.records` : 한 번에 가져올 최대 레코드 개수 (크기가 아닌 개수를 제어)
- `max.partition.fetch.bytes` : 파티션별 반환할 최대 데이터 크기 (레코드 객체의 크기 제한)

### Session Timeout 및 H/B 설정

- `session.timeout.ms` : 하트비트 없이 컨슈머를 살아있다고 간주할 최대 시간 (기본 10초)
- `heartbeat.interval.ms`: 하트비트 전송 간격 (일반적으로 `session.timeout.ms`의 1/3)
- `max.poll.interval.ms` : 폴링 간 최대 대기 시간 (기본 5분, H/B와 Session Timeout으로 죽은 컨슈머를 걸러낸다면 해당 설정값은 poll 호출 지연 시간에 대한 장치)
- `default.api.timeout.ms` : 모든 API 호출에 적용되는 기본 타임아웃 
- `request.timeout.ms` : 브로커 응답 대기 최대 시간 (기본 30초)

### Offset 및 Commit 설정

- `auto.offset.reset` : 메시지를 읽기 시작할 위치 지정 (보통 컨슈머가 오랫동안 레코드를 읽지 않아 브로커에서 삭제됐을 때)
    - `earliest` : 처음부터 읽음
    - `latest` : 최신 메시지부터 읽음
- `enable.auto.commit` : 오프셋 자동 커밋 여부 설정 (true의 경우 auto.commit.interval.ms 설정 필요)

### 파티션 할당 전략
- `partition.assignment.strategy`
  - `Range` : 컨슈머 그룹 내에서 연속된 파티션을 하나의 컨슈머에 할당하는 전략
  - `RoundRobin` : 파티션을 컨슈머 그룹 내의 모든 컨슈머에게 고르게 분배하는 전략
  - `Sticky` : 파티션을 균등하게 분배하며, 리밸런스 시 파티션 이동을 최소화하는 전략
  - `Cooperative Sticky` : Sticky에 협력적 리밸런스를 추가해 점진적인 파티션 재할당을 지원하는 전략

### 기타 설정

- `client.id`: 로깅/모니터링 메트릭, 쿼터 클라이언트 식별 ID
- `client.rack`: 레플리카를 가져올 데이터센터/클라우드 영역 지정 (같은 랙은 물리적으로 같은 위치에 있음을 말한다)
- `group.instance.id`: 정적 그룹 멤버십 활성화로 리밸런스 최소화
- `receive.buffer.bytes`, `send.buffer.bytes`: TCP 송수신 버퍼 크기 설정 (`-1`은 OS 기본값 사용), 다른 가용영역의 데이터센터와 통신 시 대역폭이 낮아 값을 크게 설정
- `offsets.retention.minutes`: 컨슈머 그룹이 각 파티션에 대해 커밋한 오프셋 값은 컨슈머 그룹이 모두 할당을 해제한 경우 이 설정값에 지정된 기간 동안만 보관하게 됨

