## 6. 카프카 내부 메커니즘

### 클러스터 멤버쉽
- 각 브로커는 브로커 설정 파일에 정의되었거나 자동으로 생성된 고유한 식별자를 가진다.
- 브로커 프로세스는 시작될 때 주키퍼에 Ephemeral 노드의 형태로 ID를 등록하고, 카프카 브로커들과 몇몇 생태계 툴들은 해당 ID가 저장된 /brokers/ids를 구독하여 이벤트를 받는다.

### 컨트롤러 
- 일반적인 카프카 브로커의 기능 + 파티션 리더를 선출하는 역할 
- 클러스터에서 가장 먼저 시작되는 브로커는 주키퍼의 /controller 에 Ephemeral 노드를 생성함으로써 컨트롤러가 된다. 
- 다른 브로커는 '노드가 이미 존재함' 예외를 받으면 컨트롤러 노드가 이미 있다는 걸 알아차리게 된다. 
- 브로커들은 주키퍼의 컨트롤러 노드에 변동이 생겼을 때 알림을 받기 위해 '와치'를 설정하고, 클러스터 안에 한 번에 한 개의 컨트롤러만 있도록 보장한다. 

#### Ephemeral 노드가 삭제될 경우 
- 와치를 통해 이를 알게 되고, 주키퍼에 컨트롤러 노드를 생성하려고 시도한다. 
- 가장 먼저 새로운 노드를 생성한 브로커가 다음 컨트롤러가 되고, 다른 브로커는 새 컨트롤러 노드에 대한 와치를 다시 생성한다. 
- 컨트롤러 좀비
  - 새로운 컨트롤러가 선출될 때마다 '증가된 에포크 값'을 전달받는다. 
  - 이것은 컨트롤러 브로커가 오랫동안 가비지 수집 때문에 멈춘 사이 주키퍼 사이의 연결이 끊어질 수 있기 때문에 중요하다.
  - 컨트롤러가 전송하는 메시지에 컨트롤러 에포크를 포함하면 브로커는 예전 컨트롤러가 보내온 메시지를 무시할 수 있다. 
- 브로커가 컨트롤러가 되면 클러스터 메타데이터 관리와 리더 선출을 시작하기 전에 먼저 주키퍼로부터 최신 레플리카 상태 맵을 읽어온다. 
- 브로커가 클러스터를 나가면, 컨트롤러는 해당 브로커가 리더를 맡고 있던 모든 파티션에 대해 새로운 브로커를 할당해준다. 

## KRaft 
- 주키퍼 기반 컨트롤러로부터 탈피해서, 래프트 기반 컨트롤러로 옮겨간다. 
- 왜 카프카 커뮤니티는 컨트롤러를 교체하기로 결정했을까? 
  - 컨트롤러가 주키퍼에 메타데이터를 쓰는 작업은 동기적으로 이루어지지만, 브로커 메시지를 보내는 작업은 비동기적으로 이루어진다. 그렇기 때문에 브로커, 컨트롤러, 주키퍼 간에 메타 데이터 불일치가 발생할 수도 있다. 
  - 컨트롤러가 재시작될 때마다 주키퍼로부터 모든 브로커와 파티션에 대한 메타데이터를 읽어오고, 그것들을 모든 브로커로 전송해야 하는데 브로커와 파티션 수가 증가함에 따라 컨트롤러 재시작은 느려진다. 
### 현재 아키텍처에서 주키퍼 역할 
- 컨트롤러 선출과 클러스터 메타데이터(운영 중인 브로커, 설정, 토픽, 파티션, 그리고 레플리카 정보) 저장 
- 카프카 그 자체에 사용자가 상태를 이벤트 스트림으로 나타낼 수 있도록 로그 기반 아키텍처를 도입
- 다수의 컨슈머를 사용해서 이벤트를 재생함으로써 최신 상태를 빠르게 따라잡는다. 
- 또한 컨트롤러 노드들은 메타데이터 이벤트 로그를 관리하는 래프크 쿼럼이 된다. 이 로그는 클러스터 메타데이터의 변경내역을 저장한다.
### 장점
- 컨트롤러 노드들은 외부 시스템에 의존하지 않고 자체적으로 리더 선출
- 메타데이터 로그의 리더 역할을 맡고 있는 컨트롤러(액티브 컨트롤러)는 브로커가 보내온 모든 RPC 호출을 처리한다. 
- 팔로워 컨트롤러들은 액티브 컨트롤러에 쓰여진 데이터들을 복제하고, 장애 발생 시 즉시 투입될 수 있도록 한다. 
- 컨트롤러들은 모두 최신 상태이므로 장애 복구는 리로드 기간을 필요로 하지 않는다. 

## 복제 
- 카프카에 저장되는 데이터는 토픽을 단위로 하고, 각 토픽은 1개 이상의 파티션으로 분할되고, 각 파티션은 다수의 레플리카를 가질 수 있다. 
- 각각의 레플리카는 브로커에 저장되는데, 하나의 브로커는 수백 개, 수천 개의 레플리카를 저장한다. 
### 리더 레플리카 
- 각 파티션 당 리더 레플리카 하나가 있다. 
- 일관성 보장을 위해 모든 쓰기 요청은 리더 레플리카로 주어진다. 
### 팔로워 레플리카 
- 파티션에 속한 레플리카 중 리더 레플리카를 제외한 나머지 
- 팔로워는 원래 클라이언트의 요청을 처리할 수 없다.
- 리더 레플리카로 들어온 최근 메시지를 복제한다.
- 해당 파티션의 리더 레플리카에 크래쉬가 날 경우, 팔로워 레플리카 중 하나가 파티션의 새 리더 파티션으로 승격된다.
### 모든 레플리카의 복제 상태가 뒤처질 때 
- 팔로워 레플리카는 리더 레플리카와의 동기화를 위해 읽기 요청을 보낸다.(컨슈머가 브로커에게 보내는 요청과 동일하다)
- 이러한 요청에 대한 응답으로, 리더 레플리카는 메시지를 되돌려 준다. 
- 이 읽기 요청들은 복제를 수행하는 입장에서 다음 번에 받아야할 메시지 오프셋 + 언제나 메시지를 순서대로 돌려준다. 
- 리더 레플리카는 각 팔로워 레플리카가 마지막으로 요청한 오프셋 값을 확인함으로써 각 팔로워 레플리카가 얼마나 뒤쳐져 있는 알 수 있다. 
- 팔로워 레플리카가 못 따라잡은 경우(out-of-sync-replica)는 더 이상 장애 상황에서 리더 될 수 없다. 
- 반대로 지속적으로 최신 메시지를 요청하고 있는 레플리카(in-sync-replica)는 파티션 리더로 선출 가능하다. 

## 요청 처리 
- 카프카 브로커가 하는 일은 클라이언트, 파티션 레플리카, 컨트롤러가 파티션 리더에게 보내는 요청을 처리하는 것이다.
### 요카프카 내부의 요청 처리 
- 브로커는 연결을 받는 각 포트 별로 acceptor 스레드를 하나씩 실행 
- acceptor 스레드는 연결을 생성하고 들어온 요청을 프로세스 스레드에 넘겨 처리하도록한다. 
- 프로세서 스레드는 들어온 요청들을 받아서 요청 큐에 넣고, 응답 큐에서 응답을 가져다 클라이언트로 보낸다. 
- 컨슈머의 경우: 브로커 쪽에 데이터가 준비되었을 때에만 응답 보낼 수 있다. 
- 어드민 클라이언트의 경우: 토픽 삭제가 진행 중인 상황에서만 DeleteTopicrequest 요청에 대한 응답 보낼 수 있다. 

### 쓰기 요청 
- 카프카 브로커로 메시지를 쓰고 있는 프로듀서가 보낸 요청 
- acks=1: 리더만이 메시지를 받았을 때
- acks=all: 모든 in-sync 레플리카들이 메시지를 받았을 때
- acks=0: 메시지가 보내졌을 때, 즉 브로커의 응답을 기다리지 않음. 
- 유효성 검사 후, 브로커는 새 메시지들을 로컬 디스크에 쓴다. 카프카는 데이터가 디스크에 저장될 때까지 기다리지 않는다. 
- 메시지가 파티션에 쓰여지고 나면 브로커는 acks 설정에 따라 응답을 내려보낸다. 
### 읽기 요청 
- 카프카 브로커로부터 메시지를 읽어오고 있는 컨슈머나 팔로워 레플리카가 보낸 요청 
- 클라이언트는 각 파티션에 대해 브로커가 리턴할 수 있는 최대 데이터의 양 역시 지정한다. (메모리 할당을 위해)
- 요청은 파티션 리더 브로커에게 전송되어야 하고, 클라이언트는 읽기 요청을 정확히 라우팅할 수 있도록 필요한 메타 데이터에 대한 요청을 보낸다.
- 요청을 받은 파티션 리더는 오프셋이 해당 파티션에 존재하는지 확인하는데, 존재한다면 브로커는 파티션으로부터 클라이언트가 요청에 지정한 크기 한도만큼의 메시지를 읽어서 클라이언트에게 보내준다. 
- 데이터베이스와의 차이점: 카프카는 파일에서 읽어온 메시지들을 중간 버퍼를 거치지 않고 바로 네트워크 채널로 보낸다. 데이터베이스는 데이터 보내기 전에 로컬 캐시에 저장하는데, 차이가 있다. 
- **파티션 리더에 존재하는 모든 데이터를 클라이언트가 읽을 수 있는 건 아니다.**
- 대부분의 클라이언트는 모든 in-sync 레플리카에 쓰여진 메시지들만 읽을 수 있다. 
- 충분한 수의 레플리카에 복제가 완료되지 않은 메시지는 불완전한 것으로 간주된다. 
- 예를 들어서, 컨슈머가 어떤 메시지를 읽은 상태에서 리더 브로커가 크래시 나고, 다른 브로커에 해당 메시지가 복제된 적 없다면 이 메시지는 사라진다.