# Chapter 1. 카프카 시작하기
## 1.1 발행/구독 메시지 전달
- 발행/구독 메시지 전달 패턴의 특징
  - 전송자가 데이터를 보낼 때 직접 수신자로 보내지 않음
  - 전송자는 어떤 형태로든 메시지를 분류해서 보내고, 수신자는 이렇게 분류된 메시지를 구독함
- "애플리케이션이 많아짐 -> 지표 많아짐 -> 기술부채" 해결방안
  - 모든 애플리케이션으로부터 지표를 받는 하나의 애플리케이션을 만들고, 이 지푯값들을 필요로 하는 어느 시스템이든 지표를 질의할 수 있도록 해주는 서버를 제공

## 1.2 카프카 입문
- 카프카 = 메시지 발행/구독 시스템
  - 분산 커밋 로그 or 분산 스트리밍 플랫폼
- 카프카에서 데이터의 기본 단위는 메시지
  - 데이터베이스의 로우와 레코드와 비슷함
- 메시지는 키라 불리는 메타데이터를 포함할 수 있음
  - 키는 메시지를 저장할 파티션을 결정하기 위해 사용됨
  - 키값에서 일정한 해시값을 생성한 뒤 이 값을 토픽의 파티션 수로 나눴을 때 나머지 값에 해당하는 파티션에 메시지를 저장함
  - 같은 키값을 가진 메시지는 항상 같은 파티션에 저장됨
    - 파티션 수가 변하지 않았을 때
- 카프카에서는 일관적인 데이터 형식이 중요
- 카프카에 저장되는 메시지는 토픽 단위로 분류됨
  - 가장 비슷한 개념으로는 데이터베이스의 테이블이나 파일시스템의 폴더
- 토픽은 다시 여러 개의 파티션으로 나눠짐

## 1.3 왜 카프카인가?
- 다중 프로듀서
- 다중 컨슈머
- 디스크 기반 보존
- 확장성
- 고성능
- 플랫폼 기능
  - 카프카 커넥트, 카프카 스트림즈

## 1.4 데이터 생태계
- 활동 추적
- 메시지 교환
- 지표 및 로그 수집
- 커밋 로그
- 스트림 처리

## 1.5 카프카의 기원
(...생략...)

## 1.6 카프카 시작하기
(...생략...)

# Chapter 3. 카프카 프로듀서: 카프카에 메시지 쓰기
## 3.1 프로듀서 개요
- 서로 다른 요구조건은 카프카에 메시지를 쓰기 위해 프로듀서 API를 사용하는 방식과 설정에 영향을 미침
- 카프카에 메시지를 쓰는 작업은 ProducerRecord 객체를 생성하면서 시작함
  - 레코드가 저장될 토픽과 밸류는 필수사항
  - 키와 파티션은 선택사항
  - 전송하는 API를 호출했을 때 프로듀서가 가장 먼저 하는 일은 키와 값 객체가 네트워크 상에서 전송될 수 있도록 직렬화해서 바이트 배열로 변환하는 과정

## 3.2 카프카 프로듀서 생성하기
- 카프카 프로듀서의 필수 속성값 3개
  - bootstrap.servers
  - key.serializer
  - value.serialize
- 메세지 전송 방법
  - 파이어 앤 포겟
  - 동기적 전송
  - 비동기적 전송

## 3.3 카프카로 메시지 전달하기
- 동기적으로 메시지 전송
  - 실제로 사용되는 애플리케이션에서는 잘 사용되지 않음
- 비동기적으로 메시지 전송
  - 보내야 할 메시지를 전부 전송하고 응답을 기다리지 않으면 거의 시간이 걸리지 않음
  - 메시지 전송에 완전히 실패했을 경우에는 내용을 알아야 함 -> 콜백

## 3.4 프로듀서 설정하기
(...생략...)

## 3.5 시리얼라이저
(...생략...)

## 3.6 파티션
- 카프카 메시지는 키-밸류 순서쌍이라고 할 수 있는데, 키의 기본값이 null인 만큼 토픽과 밸류의 값만 있어도 객체를 생성할 수 있음
  - 하지만 대부분의 경우 키값이 지정된 레코드를 사용함
- 키의 역할은 두가지
  - 그 자체로 메시지에 함께 저장되는 추가적인 정보
  - 하나의 토픽에 속한 여러 개의 파티션 중 해당 메시지가 저장될 파티션을 결정짓는 기준점

## 3.7 헤더
- 레코드는 키값, 밸류값 외에도 헤더를 포함할 수 있음
  - 레코드 헤더는 카프카 레코드의 키/밸류값을 건드리지 않고 추가 메타데이터를 심을 때 사용

## 3.8 인터셉터
- 카프카 클라이언트의 코드를 고치지 않으면서 그 작동을 변경해야 하는 경우 ProducerInterceptor를 사용
- `ProducerRecord<K, V> onSend(ProducerRecord<K, V> record)`
  - 프로듀서가 레코드를 브로커로 보내기 전, 직렬화되기 직전에 호출
- `void onAcknowledgement(RecordMetadata metadata, Exception exception)`
  - 카프카 브로커가 보낸 응답을 클라이언트가 받았을 때 호출

## 3.9 쿼터, 스로틀링
- 브로커에는 쓰기/읽기 속도를 제한할 수 있는 기능이 있음
- 3가지 쿼터 타입에 대해 한도를 설정할 수 있음
  - 쓰기 쿼터
  - 읽기 쿼터
  - 요청 쿼터
- 클라이언트가 할당량을 다 채웠을 경우, 브로커는 클라이언트의 요청에 대한 스로틀링을 시작하여 할당량을 초과하지 않도록 함.