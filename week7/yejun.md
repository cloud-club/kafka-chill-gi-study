## Chapter 07. 신뢰성 있는 데이터 전달

### 신뢰성 보장

보장이란 서로 다른 상황에서도 시스템이 지킬 것이라 보장되는 행동을 의미한다.

아파치 카프카가 보장하는 것

- 카프카는 파티션 안의 메시지들 간에 순서를 보장
- 클라이언트가 쓴 메시지는 모든 인-싱크 레플리카의 파티션에 쓰여진 뒤에야 '커밋'된 것으로 간주
- 커밋된 메시지들은 최소 1개의 작동 가능한 레플리카가 남아 있는 한 유실되지 않음
- 컨슈머는 커밋된 메시지만 읽을 수 있음

신뢰성 있는 시스템을 구축하는데는 트레이드 오프가 있으며 신뢰성과 일관성이 우선인지 가용성, 높은 처리량, 낮은 지연, 하드웨어 비용과 같은 고려사항이 우선인지 등..

___
### 복제

- 카프카의 복제 메커니즘은 파티션별로 다수의 레플리카를 유지한다는 특성과 함께 카프카의 신뢰성 보장의 핵심
- 하나의 메시지를 여러 개의 레플리카에 씀으로써 카프카는 크래시가 나더라도 메시지의 지속성을 유지한다

인-싱크 레플리카 판단 조건
- 주키퍼와 활성 세션이 있음
  - 팔로워 레플리카가 ISR에 남아있으려면, 주키퍼와의 활성 세션을 유지하고, 최근 6초 내에 하트 비트를 전송했어야 함.
  - zookeeper.session.timeout.ms = 6000 (6초)
- 최근 10초 사이에 리더로부터 읽어 온 메시지들이 가장 최근 메시지, 팔로워가 리더로부터 메시지를 받고 있는 것만으로는 부족하다 `최근 10초 사이 랙(lag, 지연)이 없었던 적이 최소 1번은 있어야 한다`
  - 팔로워 레플리카가 ISR에 머무르기 위해 리더와의 랙(lag, 지연)이 replica.lag.time.max.ms안에 해결되어야 함
  - 정상적으로 복제한 상태를 10초내에 최소 한 번 보여야 ISR로 간주
 
```
동기화가 살짝 늦은 인-싱크 레플리카가 프로듀서와 컨슈머를 느리게 만들 수 있다.
프로듀서는 해당 레플리카가 메시지 복제할 때까지 기다려야 하고, 컨슈머 역시 커밋된 메시지를 읽기 위해 기다려야 하기에 처리 속도가 느려진다.
동기화가 풀린 Out-of-Sync Replica는 더 이상 ISR 목록에 포함되지 않으며 프로듀서와 컨슈머는 해당 Replica를 무시하기에 성능에 영향을 미치지 않게된다

-> ISR 목록에 포함되지 않기에 ISR 수가 줄어들고 그로 인해 복제본의 안정성이 떨어지고 클러스터의 신뢰성과 가용성에도 영향을 미치게 된다
```
___

### 브로커 설정

#### 복제 팩터
복제 팩터를 토픽 단위로 설정: replication.factor

토픽에 대한 복제 팩터 브로커 단위 설정: default.replication.factor

복제 팩터가 N이면 (N-1)개의 브로커가 중단되더라도 데이터를 읽거나 쓸 수 있다. 따라서, 복제 팩터가 클수록 가용성과 신뢰성은 늘어나고 장애 발생 가능성이 줄어든다

대신에 N개의 복사본을 저장해야 하므로 N배의 디스크 공간이 필요하다.

`토픽에 몇 개의 Replica가 적절한지 결정할 때 핵심 고려 사항`
1. 가용성
2. 지속성
- 디스크 장애 시 해당 파티션의 모든 데이터는 유실, 복사본이 많을수록 데이터가 유실될 가능성은 줄어듦
3. 처리량
- 레플리카 추가 시 브로커간 트래픽이 늘어남
4. 종단 지연
- 메시지를 컨슈머가 읽으려면 모든 인-싱크 레플리카에 복제되어야함
- 특정 레플리카가 느려지면 컨슈머까지 함께 느려짐
5. 비용
- 중요하지 않은 데이터에 대해 복제 팩터를 3미만으로 잡아 주는 가장 일반적인 이유
- 네트워크, 저장 장치 비용

++ 랙 분산
___

### 언클린 리더 선출

- 클린 리더 선출 (Clean Leader Election)
  - ISR에 있는 레플리카 중 하나가 리더로 선출되며, 데이터 손실이 발생하지 않는 상황을 클린 리더 선출이라고 함.
- 언클린 리더 선출 (Unclean Leader Election)
  - ISR이 아닌 레플리카(리더와 동기화되지 않은 레플리카)가 리더로 선출되는 상황
  - 데이터 손실 가능성 있는 상태에서 리더를 선출해야 하는 비정상적인 경우

`인-싱크 레플리카가 없는 상황`
1. 파티션에 3개의 레플리카가 있고, 팔로워 2개가 장애
리더가 살아있으므로, 프로듀서는 리더에 쓰기 작업을 계속하다가 리더가 장애가 난 후 팔로워 중 하나가 먼저 시작되면
해당 파티션의 유일한 사용 가능한 레플리카가 아웃-오브-싱크 레플리카가 된다.

2. 파티션에 3개의 레플리카가 있고, 네트워크 문제가 발생해서 팔로워 2개의 복제가 뒤쳐짐
복제가 계속 되겠지만 인-싱크 레플리카가 아님 이 때 리더가 장애가 발생하면
리더가 될 수 있는 레플리카는 아웃-오브-싱크 레플리카 밖에 없다.

`이런 상황에서 둘 중 하나의 결정을 해야 한다`

1. 아웃-오브-싱크 레플리카가 새 리더가 될 수 없도록 한다면, 예전 리더가 복구될 때까지 해당 파티션은 오프라인 상태가 된다.
2. 아웃-오브-싱크 레플리카가 새 리더가 될 수 있도록 한다면, 데이터의 유실과 일관성 깨짐의 위험성이 있다.

```
# Kafka는 복제본 중 ISR에 있는 노드에서만 새로운 리더를 선출
unclean.leader.election.enable=false #기본값

# ISR에 없는 복제본을 리더로 선출 가능
unclean.leader.election.enable=true
```
___

### 최소 인-싱크 레플리카

- 토픽과 브로커 단위 모두 min.insync.replicas 설정을 해줄 수 있다
  - min.insync.replicas: ISR에 있어야 하는 최소 레플리카 수
  - min.insync.replicas을 만족하지 못하면 프로듀서는 브로커에 더이상 쓰기 작업을 못하고 해당 조건을 만족할 때 까지 읽기전용처럼 작동
- 토픽에 레플리카가 3개 있고, min.insync.replicas를 2로 잡아줬다면 프로듀서들은 3개의 레플리카 중 최소 2개가 인-싱크 상태인 파티션에만 쓸 수 있다.
___

### 레플리카를 인-싱크 상태로 유지하기

Out-of-Sync가 될 수 있는두 가지 이유

- 주키퍼와 활성 세션을 유지해야 하는데, 주키퍼와의 연결이 끊어짐
- 리더 업데이트 내역을 따라가는 데 실패 - 복제 랙(lag, 지연)이 발생하거나 

**zookeeper.session.timeout.ms: 카프카 브로커와 주키퍼 간 세션이 유지될 최대 시간**
```
브로커는 zookeeper.session.timeout.ms 시간 동안 주키퍼와의 연결을 유지하기 위해 주기적으로 하트 비트를 전송해야 함.
이 시간동안 하트비트를 주키퍼로 보내지 못하면 주키퍼는 해당 브로커가 더이상 호환 상태가 아니라고 판단, 세션을 종료
(네트워크 지연의 변동폭이 큰 클라우드 환경의 클러스터 안정성을 증대시키기 위해 버전 2.5.0부터 18초가 디폴트)
18초 동안 하트비트를 주키퍼로 보내지 못하면 주키퍼와는 해당 브로커가 더이상 활성상태가 아니라고 판단하고 세션 종료
```

**replica.lag.time.max.ms: 팔로워 레플리카가 리더에게 데이터를 복제하지 못한 상태로 허용되는 최대 시간(밀리초)**
```
replica.lag.time.max.ms = 10000 : 팔로워 레플리카가 10초동안 리더 레플리카와 동기화를 유지하지 못하면 ISR에서 제거됨
(클러스터의 회복 탄력성을 증대시키고 불필요한 변동을 피하기 위해 버전 2.5.0에서 30초로 조정)
```
___

### 디스크에 저장하기

카프카는 세그먼트를 교체할 때(기본값: 1GB)와 재시작 직전에만 메시지를 디스크로 플러시

그 외 경우는 리눅스의 페이지 캐시 기능에 의존 (더티 페이지가 쌓이면 플러시 되는..)

브로커가 디스크에 더 자주 메시지를 저장하도록 설정 (fsync가 카프카의 처리량에 어떤 영향을 미칠까..)
- flush.messages: 디스크에 젖아되지 않은 최대 메시지 수
- flush.ms: 얼마나 자주 디스크에 메시지를 저장

___

### 신뢰성 있는 시스템에서 프로듀서 사용하기
